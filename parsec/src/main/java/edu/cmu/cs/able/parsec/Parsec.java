package edu.cmu.cs.able.parsec;

import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;

import edu.cmu.cs.able.parsec.parser.ParseException;
import edu.cmu.cs.able.parsec.parser.ParsecParser;
import edu.cmu.cs.able.parsec.parser.ParsecParserTokenManager;
import edu.cmu.cs.able.parsec.parser.SimpleCharStream;

import incubator.pval.Ensure;

/**
 * Class used to perform parsing. The normal use of this class is to create
 * an instance, add delegate parsers using the {@link #add(DelegateParser)}
 * method and then invoking parsing on a {@link TextContainer} using the
 * {@link #parse(TextContainer, Object)} method. The container may be obtained 
 * be obtained through the {@link ParsecFileReader} class.
 * @param <T> the type of parsing context, information passed from the parsec
 * parser to the delegate parsers
 */
public class Parsec<T> {
	/**
	 * List of delegate parsers.
	 */
	private List<DelegateParser<T>> m_parsers;
	
	/**
	 * Creates a new instance.
	 */
	public Parsec() {
		m_parsers = new ArrayList<>();
	}
	
	/**
	 * Adds a delegate parser.
	 * @param parser the parser
	 */
	public void add(DelegateParser<T> parser) {
		Ensure.notNull(parser);
		m_parsers.add(parser);
	}
	
	/**
	 * Parses a container using a specific post listener. This method is
	 * invoked internally and by unit tests. Separation of this method
	 * from {@link #parse(TextContainer, Object)} required the creation of the
	 * {@link ParsecParserPostListener} class to separate parser callbacks
	 * from delegation invocation.
	 * @param container the container
	 * @param l the listener
	 * @throws LocalizedParseException parsing failed
	 */
	void parse_i(TextContainer container, ParsecParserPostListener l)
			throws LocalizedParseException {
		assert container != null;
		assert l != null;
		
		try (Reader rdr = container.reader()) {
			SimpleCharStream stream = new SimpleCharStream(rdr);
			ParsecParserTokenManager tm = new ParsecParserTokenManager(stream);
			ParsecParser parser = new ParsecParser(tm);
			ParseContext ctx = new ParseContext(container, l);
			try {
				parser.File(ctx);
			} catch (LocalizedParseException e) {
				throw e;
			} catch (ParseException e) {
				LCCoord loc;
				if (e.currentToken != null) {
					loc = new LCCoord(e.currentToken.beginLine,
							e.currentToken.beginColumn);
				} else {
					loc = new LCCoord(1, 1);
				}
				throw new LocalizedParseException(e.getMessage(), loc);
			}
		} catch (IOException e) {
			/*
			 * Never happens.
			 */
			assert false;
		}
	}
	
	/**
	 * Parses the text in a container invoking delegate parsers to perform
	 * the parsing of each statement and block. At least one delegate parser
	 * must have been added.
	 * @param container the text to parse (see {@link ParsecFileReader})
	 * @param context context to pass to the delegates in the
	 * {@link DelegateParser#parse_statement(String, Object)} and
	 * {@link DelegateParser#parse_block(String, String, Object)} methods;
	 * the context may be <code>null</code>
	 * @throws LocalizedParseException failed to parse the text; this may be
	 * generated by a failure of the <code>parsec</code> parser itself or by
	 * a failure in a delegate parser; the location provided in the exception
	 * is the location where parsing failed
	 */
	public void parse(TextContainer container, T context)
			throws LocalizedParseException {
		Ensure.not_null(container);
		Ensure.greater(m_parsers.size(), 0);
		
		parse_i(container, new ParsecDelegationPostListener<>(m_parsers,
				context));
	}
	
	/**
	 * Parsing context. This class is invoked by the parser itself whenever it
	 * encounters a statement or a block.
	 */
	class ParseContext implements ParsecParserListener {
		/**
		 * The text we're parsing.
		 */
		private TextContainer m_container;
		
		/**
		 * Listener to invoke.
		 */
		private ParsecParserPostListener m_post_listener;
		
		/**
		 * Create a new context.
		 * @param container the container
		 * @param pl the post-listener to invoke when we receive callbacks
		 * from the parser
		 */
		ParseContext(TextContainer container, ParsecParserPostListener pl) {
			Ensure.not_null(container);
			Ensure.not_null(pl);
			m_container = container;
			m_post_listener = pl;
		}
		
		@Override
		public void statement_recognized(String text, LCCoord loc)
				throws ParseException {
			loc = advance_whitespace(text, loc);
			text = StringUtils.trim(text);
			TextRegionMatch m = m_container.locate(loc);
			m_post_listener.statement_recognized(text, m);
		}

		@Override
		public void block_recognized(String block_header, String block_text,
				LCCoord loc) throws ParseException {
			/*
			 * Compute the location of the block text in absolute coordinates.
			 * Skipping (1) the block header, (2) the braces, (3) any white
			 * space in the beginning of the block text.
			 */
			LCCoord b_loc = new LCCoord(loc.line(), loc.column());
			b_loc = advance(block_header, b_loc);
			b_loc = new LCCoord(b_loc.line(), b_loc.column() + 1);
			b_loc = advance_whitespace(block_text, b_loc);
			
			loc = advance_whitespace(block_header, loc);
			
			block_text = StringUtils.trim(block_text);
			block_header = StringUtils.trim(block_header);
			
			TextRegionMatch hm = m_container.locate(loc);
			TextRegionMatch bm = m_container.locate(b_loc);
			m_post_listener.block_recognized(block_header, hm, block_text, bm);
		}
		
		/**
		 * Clears leading and trailing whitespace from text.
		 * @param text the text
		 * @param loc the text location
		 * @return the new location start, advanced by removing the leading
		 * whitespace
		 */
		private LCCoord advance_whitespace(String text, LCCoord loc) {
			int line = loc.line();
			int column = loc.column();
			for (int idx = 0; idx < text.length(); idx++) {
				if (!Character.isWhitespace(text.charAt(idx))) {
					break;
				}
				
				if (text.substring(idx).startsWith(
						SystemUtils.LINE_SEPARATOR)) {
					line++;
					column = 1;
					idx += SystemUtils.LINE_SEPARATOR.length() - 1;
				} else {
					column++;
				}
			}
			
			return new LCCoord(line, column);
		}
		
		/**
		 * Advances a location which is assumed to start at the begining of
		 * the text, to the end of the text.
		 * @param text the text
		 * @param loc the location
		 * @return the location at the first position past the end of the
		 * text
		 */
		private LCCoord advance(String text, LCCoord loc) {
			Ensure.not_null(text);
			Ensure.not_null(loc);
			
			int line = loc.line();
			int column = loc.column();
			for (int idx = 0; idx < text.length(); idx++) {
				if (text.substring(idx).startsWith(System.lineSeparator())) {
					line++;
					column = 1;
				} else {
					column++;
				}
			}
			
			return new LCCoord(line, column);
		}
	}
}
